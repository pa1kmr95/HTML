<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earn Rule Builder ‚Äì MVP (Base + Cap, value engine)</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #111827;
      background: #f3f4f6;
    }
    body { margin: 0; padding: 0; }
    .app-shell {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
    }
    header { margin-bottom: 16px; }
    header h1 { margin: 0; font-size: 24px; }
    header .subtitle { color: #6b7280; font-size: 13px; margin-top: 4px; }
    .layout {
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(320px, 1.1fr);
      gap: 16px;
      align-items: flex-start;
    }
    .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px 18px;
      margin-bottom: 12px;
      box-shadow: 0 1px 3px rgba(15,23,42,0.08);
      border: 1px solid #e5e7eb;
    }
    .card h2 { font-size: 16px; margin: 0 0 4px 0; }
    .card h3 { font-size: 14px; margin: 12px 0 4px 0; }
    .hint { font-size: 12px; color: #6b7280; margin-bottom: 8px; }
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px 16px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }
    label { font-weight: 500; }
    input[type="text"], input[type="number"], input[type="date"], select, textarea {
      border-radius: 8px;
      border: 1px solid #d1d5db;
      padding: 6px 8px;
      font-size: 13px;
      font-family: inherit;
      background: #f9fafb;
    }
    textarea { min-height: 48px; resize: vertical; }
    input:focus, select:focus, textarea:focus {
      outline: 2px solid #2563eb;
      border-color: #2563eb;
      background: #ffffff;
    }
    .inline { display: flex; align-items: center; gap: 6px; font-size: 12px; }
    .tag-input { font-size: 12px; }
    .summary-card { position: sticky; top: 16px; }
    .summary-title { font-size: 15px; font-weight: 600; margin-bottom: 6px; }
    .summary-text {
      font-size: 13px;
      line-height: 1.5;
      color: #374151;
      white-space: pre-line;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      background: #eff6ff;
      color: #1d4ed8;
      margin-right: 4px;
      margin-bottom: 4px;
    }
    .pill-success { background: #ecfdf3; color: #166534; }
    .pill-warning { background: #fffbeb; color: #92400e; }
    .json-preview {
      margin-top: 10px;
      background: #0f172a;
      color: #e5e7eb;
      border-radius: 8px;
      padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 11px;
      max-height: 260px;
      overflow: auto;
    }
    .section-divider { border-top: 1px dashed #e5e7eb; margin: 10px 0; }
    .edge-note { font-size: 11px; color: #9ca3af; margin-top: 4px; }
    .slab-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 8px 12px;
      font-size: 12px;
      margin-top: 4px;
    }
    .slab-grid-header {
      font-weight: 600;
      font-size: 11px;
      color: #4b5563;
    }
    .client-summary {
      font-size: 12px;
      background: #f9fafb;
      border-radius: 8px;
      padding: 8px 10px;
      border: 1px dashed #e5e7eb;
      margin-bottom: 10px;
    }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px 16px;
    }
    .preview-output {
      margin-top: 8px;
      padding: 8px;
      background: #0f172a;
      color: #e5e7eb;
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 11px;
      white-space: pre-line;
    }
    .btn-preview {
      margin-top: 6px;
      align-self: flex-start;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #2563eb;
      background: #2563eb;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
    }
    .btn-preview:hover { background: #1d4ed8; }
    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
      .summary-card { position: static; }
    }
  </style>
</head>
<body>
<div class="app-shell">
  <header>
    <h1>Earn Rule Builder ‚Äì MVP</h1>
    <div class="subtitle">
      Base & Cap rules. Rule engine <b>only calculates earn value in ‚Çπ</b>.  
      Conversion to points happens via card-variant mapping configured in Client Settings.
    </div>
  </header>

  <div class="layout">
    <!-- LEFT: RULE BUILDER + PREVIEW -->
    <div>
      <!-- 0. CLIENT & SUMMARY -->
      <div class="card">
        <h2>0. Client</h2>
        <div class="form-grid">
          <div class="field">
            <label for="clientId">Client / Program</label>
            <select id="clientId">
              <option value="">Select‚Ä¶</option>
              <option value="BANK_HDFC">Bank ‚Äì HDFC</option>
              <option value="BANK_ICICI">Bank ‚Äì ICICI</option>
              <option value="RETAIL_X">Retail ‚Äì X</option>
            </select>
            <div class="edge-note">
              This rule belongs to the selected client.  
              Earn engine will use this client‚Äôs discount%, PG% and date/trigger settings.
            </div>
          </div>
        </div>

        <div class="client-summary" id="clientSummary">
          <!-- In real app, this is filled from backend for selected client -->
          <div><b>Client earn settings (read-only summary):</b></div>
          <div>‚Ä¢ Default discount% for earn: <span id="csDiscount">configured in Client Settings</span></div>
          <div>‚Ä¢ PG% on final price: <span id="csPg">configured in Client Settings</span></div>
          <div>‚Ä¢ Default rounding for points: <span id="csRounding">configured in Client Settings</span></div>
          <div>‚Ä¢ Trigger event: <span id="csTrigger">configured in Client Settings</span></div>
          <div>‚Ä¢ Rule date match: <span id="csDateMatch">configured in Client Settings</span></div>
          <div>‚Ä¢ Card ‚Üí point value mapping: <span>managed in Client Settings (per card variant)</span></div>
        </div>
        <div class="edge-note">
          To edit discount%, PG%, rounding or card mappings, go to the ‚ÄúClient Earn Settings‚Äù screen.
        </div>
      </div>

      <!-- 1. GENERAL RULE SETTINGS -->
      <div class="card">
        <h2>1. General Rule Settings</h2>
        <div class="hint">Identity and lifecycle of this rule for the selected client.</div>
        <div class="form-grid">
          <div class="field">
            <label for="ruleName">Rule name</label>
            <input id="ruleName" type="text" placeholder="e.g. HDFC base earn on >10% net margin" />
          </div>

          <div class="field">
            <label for="ruleType">Rule type</label>
            <select id="ruleType">
              <option value="BASE" selected>Base earn (value)</option>
              <option value="CAP">Cap / Limit (on value)</option>
            </select>
          </div>

          <div class="field">
            <label for="status">Status</label>
            <select id="status">
              <option value="DRAFT">Draft</option>
              <option value="ACTIVE">Active</option>
              <option value="PAUSED">Paused</option>
            </select>
          </div>

          <div class="field">
            <label for="precedence">Precedence (for BASE rules)</label>
            <select id="precedence">
              <option value="SKU_OVERRIDE">SKU override (strongest)</option>
              <option value="CATEGORY_RULE">Category / tier rule</option>
              <option value="PROGRAM_DEFAULT">Program default / fallback</option>
            </select>
            <div class="edge-note">
              For BASE rules, engine picks exactly one rule (no stacking).  
              CAP rules always stack as the tightest limit on earn value.
            </div>
          </div>

          <div class="field">
            <label for="effectiveFrom">Effective from</label>
            <input id="effectiveFrom" type="date" />
          </div>

          <div class="field">
            <label for="effectiveTo">Effective to</label>
            <input id="effectiveTo" type="date" />
          </div>

          <div class="field">
            <label>Evergreen / No expiration</label>
            <div class="inline">
              <input id="noExpiration" type="checkbox" />
              <span class="edge-note">If checked, end date is ignored until rule is paused.</span>
            </div>
          </div>
        </div>

        <div class="field" style="margin-top:10px;">
          <label for="ruleDescription">Internal description</label>
          <textarea id="ruleDescription" placeholder="Explain this rule for Finance, Biz, QA (e.g. target margin range, promo objective)."></textarea>
        </div>
      </div>

      <!-- 2. CONDITIONS -->
      <div class="card">
        <h2>2. Conditions ‚Äì Who / What</h2>
        <div class="hint">
          Define when this rule should apply. Net margin is computed using client‚Äôs discount% and PG% (excl. GST).
        </div>

        <h3>Customer & Card</h3>
        <div class="form-grid">
          <div class="field">
            <label for="tiers">Customer tier(s)</label>
            <input id="tiers" type="text" class="tag-input" placeholder="e.g. Silver, Gold, Platinum" />
          </div>

          <div class="field">
            <label for="segments">Customer segment(s)</label>
            <input id="segments" type="text" class="tag-input" placeholder="e.g. New, High-value" />
          </div>

          <div class="field">
            <label for="cardVariants">Bank card variant(s)</label>
            <input id="cardVariants" type="text" class="tag-input" placeholder="e.g. Infinia, Regalia, Millenia" />
          </div>
        </div>

        <h3>Catalog & Channel</h3>
        <div class="form-grid">
          <div class="field">
            <label for="categories">Product categories</label>
            <input id="categories" type="text" class="tag-input" placeholder="e.g. Mobiles, TV, Travel" />
          </div>

          <div class="field">
            <label for="brands">Brand(s)</label>
            <input id="brands" type="text" class="tag-input" placeholder="e.g. Apple, Samsung, Sony" />
          </div>

          <div class="field">
            <label for="skuList">Specific SKU IDs (optional)</label>
            <textarea id="skuList" placeholder="One SKU ID per line, or comma-separated."></textarea>
            <div class="edge-note">
              If filled, this rule is SKU-specific and will usually override generic rules (via precedence).
            </div>
          </div>

          <div class="field">
            <label for="channels">Channel(s)</label>
            <input id="channels" type="text" class="tag-input" placeholder="e.g. App, Web, POS" />
          </div>
        </div>

        <h3>Price & Net Margin Conditions (MVP)</h3>
        <div class="form-grid">
          <div class="field">
            <label for="minSellingPrice">Min Selling Price (incl. GST)</label>
            <input id="minSellingPrice" type="number" min="0" placeholder="e.g. 1000" />
          </div>

          <div class="field">
            <label for="maxSellingPrice">Max Selling Price (incl. GST)</label>
            <input id="maxSellingPrice" type="number" min="0" placeholder="blank = no limit" />
          </div>

          <div class="field">
            <label for="minMarginValue">Min net margin value (‚Çπ, excl. GST)</label>
            <input id="minMarginValue" type="number" min="0" placeholder="e.g. 200" />
          </div>

          <div class="field">
            <label for="maxMarginValue">Max net margin value (‚Çπ, excl. GST)</label>
            <input id="maxMarginValue" type="number" min="0" placeholder="blank = no limit" />
          </div>

          <div class="field">
            <label for="minMarginPct">Min net margin % (on final price excl. GST)</label>
            <input id="minMarginPct" type="number" min="0" max="100" placeholder="e.g. 10" />
          </div>

          <div class="field">
            <label for="maxMarginPct">Max net margin % (on final price excl. GST)</label>
            <input id="maxMarginPct" type="number" min="0" max="100" placeholder="blank = no limit" />
          </div>
        </div>
        <div class="edge-note">
          Engine computes net margin (excl. GST) as:<br/>
          ‚Ä¢ FinalPrice_incl = SP_incl ‚àí (clientDefaultDiscount% √ó SP_incl / 100)<br/>
          ‚Ä¢ FinalPrice_excl = FinalPrice_incl √∑ (1 + GST%)<br/>
          ‚Ä¢ Cost_excl = CP_incl √∑ (1 + GST%)<br/>
          ‚Ä¢ PG_cost = clientPgRate% √ó FinalPrice_incl<br/>
          ‚Ä¢ TotalCost_excl = Cost_excl + PG_cost<br/>
          ‚Ä¢ NetMarginValue_excl = FinalPrice_excl ‚àí TotalCost_excl<br/>
          ‚Ä¢ NetMarginPct_excl = NetMarginValue_excl √∑ FinalPrice_excl
        </div>
      </div>

      <!-- 3. ACTION ‚Äì BASE vs CAP -->
      <div class="card">
        <h2>3. Action ‚Äì What does this rule do?</h2>
        <div class="hint">
          MVP supports only Base earn (margin-based slabs) and Cap rules.  
          Base rules decide how much <b>earn value in ‚Çπ</b> to give; caps bound that value.
        </div>

        <!-- BASE RULE CONFIG -->
        <div id="actionBase">
          <h3>Base earn ‚Äì margin-based slabs (value)</h3>

          <div class="field">
            <label for="slabBasis">Slab basis</label>
            <select id="slabBasis">
              <option value="MARGIN_PCT">Net margin % (on final price excl. GST)</option>
              <option value="MARGIN_VALUE">Net margin value (‚Çπ, excl. GST)</option>
            </select>
            <div class="edge-note">
              Basis decides which metric is used to choose the slab.  
              The reward itself is always expressed as <b>% of net margin value in ‚Çπ</b>.
            </div>
          </div>

          <div class="field">
            <label>Margin slabs & % of net margin to reward (as earn value)</label>
            <div class="slab-grid slab-grid-header">
              <div>From</div>
              <div>To</div>
              <div>% of net margin value as earn value (‚Çπ)</div>
            </div>
            <div class="slab-grid">
              <input id="slab1From" type="number" placeholder="e.g. 0" />
              <input id="slab1To" type="number" placeholder="e.g. 5" />
              <input id="slab1Share" type="number" placeholder="e.g. 10" />
            </div>
            <div class="slab-grid">
              <input id="slab2From" type="number" placeholder="e.g. 5" />
              <input id="slab2To" type="number" placeholder="e.g. 10" />
              <input id="slab2Share" type="number" placeholder="e.g. 20" />
            </div>
            <div class="slab-grid">
              <input id="slab3From" type="number" placeholder="e.g. 10" />
              <input id="slab3To" type="number" placeholder="e.g. 999" />
              <input id="slab3Share" type="number" placeholder="e.g. 30" />
            </div>
            <div class="edge-note">
              Engine:<br/>
              ‚Ä¢ Computes net margin (value/%).<br/>
              ‚Ä¢ Picks slab based on basis and ranges.<br/>
              ‚Ä¢ EarnValue_in_‚Çπ = NetMarginValue_excl √ó (slab% / 100).<br/>
              ‚Ä¢ Conversion to points is done later using card-variant mapping.
            </div>
          </div>

          <div class="field">
            <label for="roundingMode">Rounding mode (for points later)</label>
            <select id="roundingMode">
              <option value="CLIENT_DEFAULT">Use client default rounding</option>
              <option value="FLOOR">Round down</option>
              <option value="CEIL">Round up</option>
              <option value="NEAREST_1">Round to nearest 1 point</option>
              <option value="NEAREST_50">Round to nearest 50 points</option>
              <option value="NEAREST_100">Round to nearest 100 points</option>
            </select>
            <div class="edge-note">
              This does <b>not</b> affect earn value in ‚Çπ, only how points are rounded later:  
              rule rounding ‚Üí card rounding override ‚Üí client default rounding.
            </div>
          </div>
        </div>

        <!-- CAP CONFIG -->
        <div id="actionCap" style="display:none;">
          <h3>Cap / Limit configuration (on earn value)</h3>
          <div class="form-grid">
            <div class="field">
              <label for="capScope">Cap scope</label>
              <select id="capScope">
                <option value="PER_TXN">Per transaction</option>
                <option value="PER_SKU">Per SKU line item</option>
                <option value="PER_CUSTOMER_MONTH">Per customer per month</option>
              </select>
            </div>

            <div class="field">
              <label for="capType">Cap type (all in ‚Çπ terms)</label>
              <select id="capType">
                <option value="ABSOLUTE_VALUE">Absolute max earn value (‚Çπ)</option>
                <option value="PCT_FINAL_PRICE_INCL">Max % of final price (incl. GST) as earn value</option>
                <option value="PCT_FINAL_PRICE_EXCL">Max % of final price (excl. GST) as earn value</option>
                <option value="PCT_MARGIN_VALUE">Max % of net margin value as earn value</option>
              </select>
            </div>

            <div class="field">
              <label for="capValue">Cap value</label>
              <input id="capValue" type="number" min="0" placeholder="e.g. 5000 or 5 or 40" />
            </div>
          </div>
          <div class="edge-note">
            Examples:<br/>
            ‚Ä¢ Max earn value = ‚Çπ5,000 per transaction (ABSOLUTE_VALUE).<br/>
            ‚Ä¢ Max earn value = 5% of final price excl./incl. GST.<br/>
            ‚Ä¢ Max earn value = 40% of net margin value.<br/>
            Engine applies all matching CAP rules and uses the tightest cap on <b>earn value in ‚Çπ</b>.  
            Points are then computed from this capped value using card mappings.
          </div>
        </div>
      </div>

      <!-- 4. SAMPLE CALCULATOR (PREVIEW) -->
      <div class="card">
        <h2>4. Sample calculator (preview for this rule)</h2>
        <div class="hint">
          Enter a sample product and card variants to see approximate earn value (‚Çπ) and points.  
          In production, this logic should be backed by the same engine + client cap rules.
        </div>

        <h3>4.1 Sample product & client economics</h3>
        <div class="preview-grid">
          <div class="field">
            <label for="pSpIncl">Selling price (incl. GST)</label>
            <input id="pSpIncl" type="number" min="0" placeholder="e.g. 50000" />
          </div>
          <div class="field">
            <label for="pCpIncl">Cost price (incl. GST)</label>
            <input id="pCpIncl" type="number" min="0" placeholder="e.g. 40000" />
          </div>
          <div class="field">
            <label for="pGstPct">GST %</label>
            <input id="pGstPct" type="number" min="0" max="100" placeholder="e.g. 18" />
          </div>
          <div class="field">
            <label for="pClientDiscountPct">Client default discount % (for preview)</label>
            <input id="pClientDiscountPct" type="number" min="0" max="100" placeholder="e.g. 5" />
            <div class="edge-note">
              In real system, this comes from Client Settings (defaultDiscount%).
            </div>
          </div>
          <div class="field">
            <label for="pPgRatePct">PG charges % (for preview)</label>
            <input id="pPgRatePct" type="number" min="0" max="100" placeholder="e.g. 2" />
            <div class="edge-note">
              In real system, this comes from Client Settings (pgRate%).
            </div>
          </div>
        </div>

        <h3>4.2 Optional cap for preview</h3>
        <div class="preview-grid">
          <div class="field">
            <label for="pCapType">Assumed cap type (preview)</label>
            <select id="pCapType">
              <option value="">No cap in preview</option>
              <option value="ABSOLUTE_VALUE">Absolute max earn value (‚Çπ)</option>
              <option value="PCT_FINAL_PRICE_INCL">Max % of final price (incl. GST)</option>
              <option value="PCT_FINAL_PRICE_EXCL">Max % of final price (excl. GST)</option>
              <option value="PCT_MARGIN_VALUE">Max % of net margin value</option>
            </select>
          </div>
          <div class="field">
            <label for="pCapValue">Cap value (preview)</label>
            <input id="pCapValue" type="number" min="0" placeholder="e.g. 5000 or 5 or 40" />
          </div>
        </div>
        <div class="edge-note">
          In production, preview should call backend and use all active CAP rules for the client.  
          Here, this is a simple approximation to help Finance sanity-check values while designing the rule.
        </div>

        <h3>4.3 Card variants (point mapping) for preview</h3>
        <div class="preview-grid">
          <div class="field">
            <label for="pCard1Name">Card 1 name</label>
            <input id="pCard1Name" type="text" placeholder="e.g. Infinia" />
          </div>
          <div class="field">
            <label for="pCard1PointValue">Card 1 point value (‚Çπ per point)</label>
            <input id="pCard1PointValue" type="number" min="0.01" step="0.01" placeholder="e.g. 0.50" />
          </div>
          <div class="field">
            <label for="pCard2Name">Card 2 name</label>
            <input id="pCard2Name" type="text" placeholder="e.g. Regalia" />
          </div>
          <div class="field">
            <label for="pCard2PointValue">Card 2 point value (‚Çπ per point)</label>
            <input id="pCard2PointValue" type="number" min="0.01" step="0.01" placeholder="e.g. 0.75" />
          </div>
        </div>

        <button type="button" class="btn-preview" onclick="runPreview()">
          Run sample calculation
        </button>

        <div id="previewOutput" class="preview-output" style="margin-top:8px;">
          Fill sample values above and click ‚ÄúRun sample calculation‚Äù to see net margin, earn value and points per card.
        </div>
      </div>
    </div>

    <!-- RIGHT: SUMMARY PANEL -->
    <div class="card summary-card">
      <div class="summary-title">Summary</div>
      <div id="badgeRow"></div>
      <div id="summaryText" class="summary-text">
        Start by selecting a client and filling rule details to see a plain-language summary.
      </div>

      <div class="section-divider"></div>
      <div class="summary-title" style="font-size:13px;">Technical payload (MVP)</div>
      <div id="jsonPreview" class="json-preview">
        {}
      </div>

      <div class="section-divider"></div>
      <div class="edge-note">
        Engine MVP notes:<br/>
        ‚Ä¢ Client settings (discount%, PG%, trigger, date match, card‚Üípoint mapping) are separate configs.<br/>
        ‚Ä¢ Base rule decides how much <b>earn value in ‚Çπ</b> to give from net margin.<br/>
        ‚Ä¢ Cap rules bound the earn value in ‚Çπ (not points).<br/>
        ‚Ä¢ A later layer converts earn value into points per card variant using the mapping table.
      </div>
    </div>
  </div>
</div>

<script>
  function $(id) { return document.getElementById(id); }

  const inputsToWatch = [
    "clientId",
    "ruleName","ruleType","status","precedence",
    "effectiveFrom","effectiveTo","noExpiration","ruleDescription",
    "tiers","segments","cardVariants","categories","brands","skuList","channels",
    "minSellingPrice","maxSellingPrice","minMarginValue","maxMarginValue","minMarginPct","maxMarginPct",
    "slabBasis","slab1From","slab1To","slab1Share",
    "slab2From","slab2To","slab2Share",
    "slab3From","slab3To","slab3Share",
    "roundingMode",
    "capScope","capType","capValue"
  ];

  function updateVisibility() {
    const ruleType = $("ruleType").value;
    const isBase = ruleType === "BASE";
    $("actionBase").style.display = isBase ? "block" : "none";
    $("actionCap").style.display = isBase ? "none" : "block";
    $("precedence").disabled = !isBase;

    const noExp = $("noExpiration").checked;
    $("effectiveTo").disabled = noExp;
    $("effectiveTo").style.opacity = noExp ? 0.5 : 1;
  }

  function getState() {
    const state = {};
    inputsToWatch.forEach(id => {
      const el = $(id);
      if (!el) return;
      if (el.type === "checkbox") state[id] = el.checked;
      else state[id] = el.value;
    });
    return state;
  }

  function buildHumanSummary(state) {
    let lines = [];

    if (!state.ruleName && !state.ruleType && !state.clientId) {
      return "Start by selecting a client and filling rule details to see a plain-language summary.";
    }

    const rType = state.ruleType || "BASE";
    const typeLabel = rType === "BASE"
      ? "Base earn rule (earn value in ‚Çπ)"
      : "Cap / limit rule (on earn value in ‚Çπ)";

    lines.push(`${typeLabel} for ${state.clientId || "selected client(s)"}.`);
    if (state.ruleName) lines.push(`Name: ‚Äú${state.ruleName}‚Äù.`);

    if (state.noExpiration) {
      lines.push("Effective from " + (state.effectiveFrom || "activation date") + " with no end date (evergreen).");
    } else if (state.effectiveFrom || state.effectiveTo) {
      lines.push(`Effective between ${state.effectiveFrom || "start"} and ${state.effectiveTo || "no end date"}.`);
    }

    let condParts = [];
    if (state.tiers) condParts.push(`customer tiers: ${state.tiers}`);
    if (state.segments) condParts.push(`segments: ${state.segments}`);
    if (state.cardVariants) condParts.push(`bank card variants: ${state.cardVariants}`);
    if (state.categories) condParts.push(`categories: ${state.categories}`);
    if (state.brands) condParts.push(`brands: ${state.brands}`);
    if (state.skuList) condParts.push(`specific SKUs targeted`);
    if (state.channels) condParts.push(`channels: ${state.channels}`);
    if (state.minSellingPrice) condParts.push(`min Selling Price (incl. GST): ${state.minSellingPrice}`);
    if (state.maxSellingPrice) condParts.push(`max Selling Price (incl. GST): ${state.maxSellingPrice}`);
    if (state.minMarginValue) condParts.push(`min net margin value (‚Çπ, excl. GST): ${state.minMarginValue}`);
    if (state.maxMarginValue) condParts.push(`max net margin value (‚Çπ, excl. GST): ${state.maxMarginValue}`);
    if (state.minMarginPct) condParts.push(`min net margin % (on final price excl. GST): ${state.minMarginPct}`);
    if (state.maxMarginPct) condParts.push(`max net margin % (on final price excl. GST): ${state.maxMarginPct}`);

    if (condParts.length > 0) {
      lines.push("");
      lines.push("üîç Applies when:");
      condParts.forEach(p => lines.push("‚Ä¢ " + p));
    }

    lines.push("");
    lines.push("‚öôÔ∏è Action:");

    if (rType === "BASE") {
      const basisLabel = state.slabBasis === "MARGIN_VALUE"
        ? "net margin value (‚Çπ, excl. GST)"
        : "net margin % (on final price excl. GST)";

      lines.push(`‚Ä¢ Choose slab based on ${basisLabel}.`);
      const slabLines = [];
      if (state.slab1From || state.slab1To || state.slab1Share) {
        slabLines.push(`  ‚Äì ${state.slab1From || "?"} to ${state.slab1To || "?"} ‚Üí reward ${state.slab1Share || 0}% of net margin value as earn value (‚Çπ)`);
      }
      if (state.slab2From || state.slab2To || state.slab2Share) {
        slabLines.push(`  ‚Äì ${state.slab2From || "?"} to ${state.slab2To || "?"} ‚Üí reward ${state.slab2Share || 0}% of net margin value as earn value (‚Çπ)`);
      }
      if (state.slab3From || state.slab3To || state.slab3Share) {
        slabLines.push(`  ‚Äì ${state.slab3From || "?"} to ${state.slab3To || "?"} ‚Üí reward ${state.slab3Share || 0}% of net margin value as earn value (‚Çπ)`);
      }
      if (slabLines.length > 0) {
        lines.push("‚Ä¢ Slabs:");
        slabLines.forEach(l => lines.push(l));
      }

      const roundingLabel = {
        CLIENT_DEFAULT: "client default rounding (applied later to points)",
        FLOOR: "round down (points)",
        CEIL: "round up (points)",
        NEAREST_1: "round to nearest 1 point",
        NEAREST_50: "round to nearest 50 points",
        NEAREST_100: "round to nearest 100 points"
      }[state.roundingMode || "CLIENT_DEFAULT"];

      lines.push("");
      lines.push(`‚Ä¢ Rounding strategy for points (after conversion): ${roundingLabel}.`);
      lines.push("‚Ä¢ Exactly one BASE rule applies per txn/SKU (no stacking of Base rules).");
    } else {
      let scopeLabel = {
        PER_TXN: "per transaction",
        PER_SKU: "per SKU line",
        PER_CUSTOMER_MONTH: "per customer per month"
      }[state.capScope || "PER_TXN"];

      let capDesc = "";
      switch (state.capType) {
        case "ABSOLUTE_VALUE":
          capDesc = `Max earn value = ‚Çπ${state.capValue || 0} ${scopeLabel}.`;
          break;
        case "PCT_FINAL_PRICE_INCL":
          capDesc = `Max earn value = ${state.capValue || 0}% of final price (incl. GST) ${scopeLabel}.`;
          break;
        case "PCT_FINAL_PRICE_EXCL":
          capDesc = `Max earn value = ${state.capValue || 0}% of final price (excl. GST) ${scopeLabel}.`;
          break;
        case "PCT_MARGIN_VALUE":
          capDesc = `Max earn value = ${state.capValue || 0}% of net margin value ${scopeLabel}.`;
          break;
      }
      lines.push("‚Ä¢ " + capDesc);
      lines.push("‚Ä¢ Multiple CAP rules can match; engine applies the tightest limit on earn value in ‚Çπ.");
    }

    if (state.ruleDescription) {
      lines.push("");
      lines.push("üìù Notes: " + state.ruleDescription);
    }

    return lines.join("\n");
  }

  function buildBadges(state) {
    const container = document.getElementById("badgeRow");
    container.innerHTML = "";

    if (state.clientId) {
      const span = document.createElement("span");
      span.className = "pill";
      span.textContent = state.clientId;
      container.appendChild(span);
    }
    if (state.ruleType) {
      const span = document.createElement("span");
      span.className = "pill";
      span.textContent = state.ruleType;
      container.appendChild(span);
    }
    if (state.status) {
      const span = document.createElement("span");
      span.className = "pill " + (state.status === "ACTIVE" ? "pill-success" : state.status === "PAUSED" ? "pill-warning" : "");
      span.textContent = state.status;
      container.appendChild(span);
    }
  }

  function updateUI() {
    updateVisibility();
    const state = getState();
    document.getElementById("summaryText").textContent = buildHumanSummary(state);
    buildBadges(state);
    document.getElementById("jsonPreview").textContent = JSON.stringify(state, null, 2);
  }

  // Simple helper for rounding preview
  function applyRounding(points, mode) {
    if (isNaN(points)) return NaN;
    if (!mode || mode === "CLIENT_DEFAULT") {
      // For preview only, assume nearest 1 if client default; real system will use actual config.
      return Math.round(points);
    }
    if (mode === "FLOOR") return Math.floor(points);
    if (mode === "CEIL") return Math.ceil(points);
    if (mode === "NEAREST_1") return Math.round(points);
    if (mode === "NEAREST_50") return Math.round(points / 50) * 50;
    if (mode === "NEAREST_100") return Math.round(points / 100) * 100;
    return Math.round(points);
  }

  function pickSlab(basisValue, basisType, slabs) {
    if (isNaN(basisValue)) return null;
    for (const s of slabs) {
      if (s.from === null || s.to === null || s.share === null) continue;
      if (basisValue >= s.from && basisValue < s.to) return s;
    }
    return null;
  }

  function runPreview() {
    const spIncl = parseFloat($("pSpIncl").value);
    const cpIncl = parseFloat($("pCpIncl").value);
    const gstPct = parseFloat($("pGstPct").value);
    const clientDisc = parseFloat($("pClientDiscountPct").value);
    const pgRate = parseFloat($("pPgRatePct").value);

    if (isNaN(spIncl) || isNaN(cpIncl) || isNaN(gstPct) || isNaN(clientDisc) || isNaN(pgRate)) {
      $("previewOutput").textContent = "Please fill Selling Price, Cost Price, GST%, client discount% and PG% to run preview.";
      return;
    }

    const gstRate = gstPct / 100;
    const finalPriceIncl = spIncl * (1 - (clientDisc / 100));
    const finalPriceExcl = finalPriceIncl / (1 + gstRate);
    const costExcl = cpIncl / (1 + gstRate);
    const pgCost = pgRate / 100 * finalPriceIncl;
    const totalCostExcl = costExcl + pgCost;
    const netMarginValueExcl = finalPriceExcl - totalCostExcl;
    const netMarginPctExcl = netMarginValueExcl / finalPriceExcl * 100;

    // Slabs
    const basis = $("slabBasis").value || "MARGIN_PCT";
    const basisValue = basis === "MARGIN_VALUE" ? netMarginValueExcl : netMarginPctExcl;

    const slabs = [
      { from: parseFloat($("slab1From").value), to: parseFloat($("slab1To").value), share: parseFloat($("slab1Share").value), label: "Slab 1" },
      { from: parseFloat($("slab2From").value), to: parseFloat($("slab2To").value), share: parseFloat($("slab2Share").value), label: "Slab 2" },
      { from: parseFloat($("slab3From").value), to: parseFloat($("slab3To").value), share: parseFloat($("slab3Share").value), label: "Slab 3" }
    ];

    const validSlabs = slabs.filter(s => !isNaN(s.from) && !isNaN(s.to) && !isNaN(s.share));
    const chosenSlab = pickSlab(basisValue, basis, validSlabs);

    let earnValueBeforeCap = 0;
    let shareUsed = 0;
    let slabLabel = "No slab matched";

    if (chosenSlab) {
      shareUsed = chosenSlab.share;
      earnValueBeforeCap = netMarginValueExcl * (shareUsed / 100);
      slabLabel = `${chosenSlab.label}: ${chosenSlab.from}‚Äì${chosenSlab.to} with share ${shareUsed}%`;
    }

    // Apply preview cap (on earn value in ‚Çπ)
    const pCapType = $("pCapType").value;
    const pCapValue = parseFloat($("pCapValue").value);
    let capValueRupees = null;

    if (pCapType && !isNaN(pCapValue)) {
      if (pCapType === "ABSOLUTE_VALUE") {
        capValueRupees = pCapValue;
      } else if (pCapType === "PCT_FINAL_PRICE_INCL") {
        capValueRupees = pCapValue / 100 * finalPriceIncl;
      } else if (pCapType === "PCT_FINAL_PRICE_EXCL") {
        capValueRupees = pCapValue / 100 * finalPriceExcl;
      } else if (pCapType === "PCT_MARGIN_VALUE") {
        capValueRupees = pCapValue / 100 * netMarginValueExcl;
      }
    }

    let earnValueAfterCap = earnValueBeforeCap;
    let capNote = "No cap applied in preview.";
    if (capValueRupees !== null && !isNaN(capValueRupees)) {
      earnValueAfterCap = Math.min(earnValueBeforeCap, capValueRupees);
      capNote = `Preview cap applied: earn value limited to ‚Çπ${capValueRupees.toFixed(2)}.`;
    }

    // Points per card
    const card1Name = $("pCard1Name").value || "Card 1";
    const card1Pv = parseFloat($("pCard1PointValue").value);
    const card2Name = $("pCard2Name").value || "Card 2";
    const card2Pv = parseFloat($("pCard2PointValue").value);
    const roundingMode = $("roundingMode").value || "CLIENT_DEFAULT";

    let cardLines = [];

    function cardLine(name, pv) {
      if (!pv || isNaN(pv) || pv <= 0) return `${name}: point value not set, cannot compute points.`;
      const rawPoints = earnValueAfterCap / pv;
      const roundedPoints = applyRounding(rawPoints, roundingMode);
      return `${name}: point value ‚Çπ${pv.toFixed(2)} ‚Üí raw ‚âà ${rawPoints.toFixed(2)} pts ‚Üí rounded ‚âà ${isNaN(roundedPoints) ? "N/A" : roundedPoints + " pts"}`;
    }

    if (!isNaN(card1Pv)) cardLines.push(cardLine(card1Name, card1Pv));
    if (!isNaN(card2Pv)) cardLines.push(cardLine(card2Name, card2Pv));
    if (cardLines.length === 0) cardLines.push("No card point values provided. Fill Card 1 / Card 2 to see points.");

    const out = [];
    out.push("üì¶ Sample product & margin");
    out.push(`SP (incl. GST): ‚Çπ${spIncl.toFixed(2)}`);
    out.push(`CP (incl. GST): ‚Çπ${cpIncl.toFixed(2)}`);
    out.push(`GST%: ${gstPct.toFixed(2)}%`);
    out.push(`Client default discount% (preview): ${clientDisc.toFixed(2)}%`);
    out.push(`PG% on final price (preview): ${pgRate.toFixed(2)}%`);
    out.push("");
    out.push(`Final price (incl. GST): ‚Çπ${finalPriceIncl.toFixed(2)}`);
    out.push(`Final price (excl. GST): ‚Çπ${finalPriceExcl.toFixed(2)}`);
    out.push(`Cost (excl. GST): ‚Çπ${costExcl.toFixed(2)}`);
    out.push(`PG cost (‚Çπ): ‚Çπ${pgCost.toFixed(2)}`);
    out.push(`Total cost (excl. GST): ‚Çπ${totalCostExcl.toFixed(2)}`);
    out.push(`Net margin value (excl. GST): ‚Çπ${netMarginValueExcl.toFixed(2)}`);
    out.push(`Net margin % (on final price excl. GST): ${netMarginPctExcl.toFixed(2)}%`);
    out.push("");
    out.push("üßÆ Base earn (this rule)");
    out.push(`Slab basis: ${basis === "MARGIN_VALUE" ? "Net margin value (‚Çπ)" : "Net margin %"}; value = ${basisValue.toFixed(2)}`);
    out.push(`Chosen slab: ${slabLabel}`);
    out.push(`Earn value before cap: ‚Çπ${earnValueBeforeCap.toFixed(2)}`);
    out.push(capNote);
    out.push(`Earn value after cap: ‚Çπ${earnValueAfterCap.toFixed(2)}`);
    out.push("");
    out.push("üé¥ Points per card (using preview mapping)");
    cardLines.forEach(l => out.push(l));
    out.push("");
    out.push("Note: This is a local preview. In production, preview should call backend so it uses real client settings, all Base rules, and all active Cap rules.");

    $("previewOutput").textContent = out.join("\n");
  }

  document.addEventListener("DOMContentLoaded", () => {
    inputsToWatch.forEach(id => {
      const el = $(id);
      if (!el) return;
      el.addEventListener("input", updateUI);
      el.addEventListener("change", updateUI);
    });
    updateUI();
  });
</script>
</body>
</html>
